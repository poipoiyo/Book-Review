# 第三章 模組化

#### 定義

一組標準化零件或獨立單元的每一項，可以用來建構更複雜的結構。

用模組化來描述相關程式碼的邏輯聚合，例如物件導向語言的一群類別、或結構化/函數式語言的函數。模組化機制有Java的套件、.NET的命名空間等。架構師必須知道開發人員如何打包程式，如果許多套件耦合緊密，要在相關工作中復用任何一個將更為困難。

值得注意的是一般有關命名空間的概念，在.NET平台平台與技術上的實作是分開的，開發人員需要精準、完全合格的命名，來區隔不同軟體資產。



#### 模組化測量

專注在三項主要概念：內聚、耦合、共生性



#### 內聚

同一模組的部件之間的關係有多緊密，在測量部件間的相關性有多緊密。理想情況是所有相關部件都被打包在一起的模組，拆開會使模組耦合增加，降低可讀性。

依照最好到最壞排序

1. 功能性內聚：模組擁有該功能所需的東西
2. 循序內聚：兩模組有交互作用，一個輸出變成另一個輸入
3. 通信內聚：兩模組形成通信鏈，例如在資料庫增加一筆紀錄，根據該紀錄產生一封電子郵件
4. 程序內聚：兩模組以特定順序執行其程式碼
5. 時間內聚：模組具備時間的相依性。例如許多模組在系統啟動時初始化。
6. 邏輯內聚：具備邏輯而非功能上的內聚，操作相關但功能上有差異。例如Java幾乎每一個專案中以StringUtils套件的形式呈現，一組作用在String的靜態方法，除此之外無任何關聯。
7. 巧合內聚：除了位於同一檔案外無其他關聯

```
模組：
1. 客戶維護:增加、更新、取得、通知客戶、獲得客戶訂單、取消客戶訂單
2. 客戶維護:增加、更新、取得、通知客戶 & 訂單維護：獲得客戶訂單、取消客戶訂單

取捨：
1. 如果訂單維護只有兩種操作那拆回到客戶維護算合理
2. 客戶維護預期成長的更大，會鼓勵開發人員尋求提取其他情維的機會嗎
3. 訂單維護是否需要取得更多客戶資訊
```

LCOM : 未透過分享欄位而與人產生共享之方法集的總和。可以協助架構師找出附帶耦合，而且不應該在一開始就單獨處理的類別。



#### 抽象性

抽象工作(類別和介面)與具體工作的比例。沒有抽象概念的代碼只是一個巨大的函式，一個有太多抽象概念的代碼庫讓開發人員很難了解東西如何串在一起。

不穩定性指標可判定代碼庫的易變程度，高度不穩定代碼在變動時，因為高度耦合而更容易出錯。

主序列距離：不穩定性與抽象性的衍生指標。因為兩者都是比例值，會落在0到1之間。理想的主序列距離是斜率為-1的斜直線(兩軸為抽象性與不穩定性)。離線越近表示平衡性越好，右上角表示太抽象為無用區，左下角表示實作太多，不易維護，是痛苦區。



#### 共生性

系統的兩個元件，如果其中一個的變動使得另一個也須有所變動，才能維持整個系統的正確性，則兩個元件即為共生。

靜態共生性指的是原始碼層級的耦合，耦合的發生程度。

1. 名子共生性(CoN)：多重元必須在一個實體的名子達成共識，最常見和可取的耦合方式，現在系統更名容易。
2. 型別共生性(CoT)：多重元件必須在一個實體的型別上達成共識，最常見的用來限制變數/參數只能是特定型別的功能。
3. 含義(CoM)或慣例共生性(CoC)：多重元件必須在特定值的含義上達成共識。例如 int TRUE = 1
4. 位置共生性(CoP)：多重元件必須在數值順序上達成共識。例如呼叫函式的參數順序。
5. 演算法共生性(CoA)：多重元件必須在演算法上達成共識。例如伺服器和客戶端的安全性雜湊演算法。



動態共生性，執行時對呼叫進行分析，判定的困難性更高

1. 執行共生性：多重元件的執行順序

   ```
   無法正常運作
   email = new Email();
   email.setRecipient("foo@example.com");
   email.setSender("me@me.com");
   email.send();
   email.setSubject("foo");
   ```

2. 時序共生性：常見於兩個執行續共同執行所引發的競爭危害

3. 數值共生性：發生於許多值彼此相關，且必須一起改變。容易發生於分散式系統，必須更新所有資料庫的某個值的時候。

4. 同一共生性：必須參考相同的實體。常見於兩個必須分享與更新同一個資料結構的獨立元件。



#### 共生性屬性

強度：依照重構的難易程度來判斷共生性的強度，應該偏好靜態而非動態的共生性，因為更容易判斷且容易改善。

局部性：測量代碼的模組之間有多接近，例如同一元件的兩個類別具有涵義共生性，則其對代碼庫產生的傷害小於兩個元件具備同樣型式的共生性。

程度：影響的大小有關



三個方針：

1. 把系統拆解成封裝元素，以減少整體的共生性
2. 減少任何跨越邊界的殘餘共生性
3. 作大化封裝邊界內的共生性

建議：

1. 程度規則：將強共生性轉變成較弱形式的共生性
2. 局部性規則：當軟體元素間的距離增加則採用較弱形式的共生性





